--- callouts/nm-dispatcher-utils.c	2013-09-13 17:23:43.000000000 +0200
+++ callouts/nm-dispatcher-utils.c	2013-09-14 11:29:55.476905441 +0200
@@ -409,7 +409,8 @@
 	g_return_val_if_fail (*out_iface == NULL, NULL);
 
 	/* Hostname changes don't require a device nor contain a connection */
-	if (!strcmp (action, "hostname"))
+	if (!strcmp (action, "hostname") ||
+	    !strcmp (action, "pre-sleep"))
 		return g_new0 (char *, 1);
 
 	/* Canonicalize the VPN interface name; "" is used when passing it through
--- src/nm-dispatcher.c	2013-09-13 17:23:43.000000000 +0200
+++ src/nm-dispatcher.c	2013-09-14 11:32:26.955899367 +0200
@@ -237,6 +237,8 @@
 		return "dhcp4-change";
 	case DISPATCHER_ACTION_DHCP6_CHANGE:
 		return "dhcp6-change";
+	case DISPATCHER_ACTION_PRE_SLEEP:
+		return "pre-sleep";
 	default:
 		break;
 	}
@@ -269,7 +271,8 @@
 	DispatchInfo *info;
 
 	/* All actions except 'hostname' require a device */
-	if (action != DISPATCHER_ACTION_HOSTNAME)
+	if (action != DISPATCHER_ACTION_HOSTNAME &&
+	    action != DISPATCHER_ACTION_PRE_SLEEP)
 		g_return_val_if_fail (NM_IS_DEVICE (device), NULL);
 	/* VPN actions require at least an IPv4 config (for now) */
 	if (action == DISPATCHER_ACTION_VPN_UP)
@@ -308,7 +311,8 @@
 	vpn_ip6_props = value_hash_create ();
 
 	/* hostname actions only send the hostname */
-	if (action != DISPATCHER_ACTION_HOSTNAME) {
+	if (action != DISPATCHER_ACTION_HOSTNAME &&
+	    action != DISPATCHER_ACTION_PRE_SLEEP) {
 		fill_device_props (device,
 		                   device_props,
 		                   device_ip4_props,
--- src/nm-dispatcher.h	2013-06-07 17:03:51.000000000 +0200
+++ src/nm-dispatcher.h	2013-09-14 11:33:34.674896652 +0200
@@ -39,7 +39,8 @@
 	DISPATCHER_ACTION_VPN_PRE_DOWN,
 	DISPATCHER_ACTION_VPN_DOWN,
 	DISPATCHER_ACTION_DHCP4_CHANGE,
-	DISPATCHER_ACTION_DHCP6_CHANGE
+	DISPATCHER_ACTION_DHCP6_CHANGE,
+	DISPATCHER_ACTION_PRE_SLEEP = 999,
 } DispatcherAction;
 
 typedef void (*DispatcherFunc) (gconstpointer call, gpointer user_data);
--- src/nm-manager.c	2013-09-13 17:23:43.000000000 +0200
+++ src/nm-manager.c	2013-09-14 11:39:46.645881739 +0200
@@ -73,7 +73,7 @@
 #include "nm-sleep-monitor.h"
 #include "nm-connectivity.h"
 #include "nm-policy.h"
-
+#include "nm-dispatcher.h"
 
 #define NM_AUTOIP_DBUS_SERVICE "org.freedesktop.nm_avahi_autoipd"
 #define NM_AUTOIP_DBUS_IFACE   "org.freedesktop.nm_avahi_autoipd"
@@ -3350,6 +3350,23 @@
 }
 
 static void
+pre_sleep_dispatcher_done (gpointer call, gpointer user_data)
+{
+	NMManager *self = (NMManager *) user_data;
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	GSList *iter;
+
+	/* Just deactivate and down all devices from the device list,
+	* to keep things fast the device list will get resynced when
+	* the manager wakes up.
+	*/
+	for (iter = priv->devices; iter; iter = iter->next)
+		nm_device_set_managed (NM_DEVICE (iter->data), FALSE, NM_DEVICE_STATE_REASON_SLEEPING);
+
+	nm_manager_update_state (self);
+}
+
+static void
 do_sleep_wake (NMManager *self)
 {
 	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
@@ -3359,13 +3376,9 @@
 	if (manager_sleeping (self)) {
 		nm_log_info (LOGD_SUSPEND, "sleeping or disabling...");
 
-		/* Just deactivate and down all devices from the device list,
-		 * to keep things fast the device list will get resynced when
-		 * the manager wakes up.
-		 */
-		for (iter = priv->devices; iter; iter = iter->next)
-			nm_device_set_managed (NM_DEVICE (iter->data), FALSE, NM_DEVICE_STATE_REASON_SLEEPING);
-
+		nm_dispatcher_call (DISPATCHER_ACTION_PRE_SLEEP, NULL, NULL,
+		                    pre_sleep_dispatcher_done, self);
+		return;
 	} else {
 		nm_log_info (LOGD_SUSPEND, "waking up and re-enabling...");
 
