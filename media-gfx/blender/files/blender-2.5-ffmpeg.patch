--- source/blender/blenkernel/intern/writeffmpeg.c   2011-06-22 12:23:10.000000000 -0300
+++ source/blender/blenkernel/intern/writeffmpeg.c   2011-07-08 12:24:17.000000000 -0300
@@ -2,7 +2,7 @@
  *  \ingroup bke
  */
 /*
- * $Id: writeffmpeg.c 36960 2011-05-27 23:33:40Z schlaile $
+ * $Id: writeffmpeg.c 37755 2011-06-23 16:10:48Z campbellbarton $
  *
  * ffmpeg-write support
  *
@@ -49,7 +49,9 @@
 
 #include "BLI_blenlib.h"
 
-#include "AUD_C-API.h" /* must be before BKE_sound.h for define */
+#ifdef WITH_AUDASPACE
+#  include "AUD_C-API.h"
+#endif
 
 #include "BKE_global.h"
 #include "BKE_idprop.h"
@@ -89,7 +91,9 @@
 static int audio_outbuf_size = 0;
 static double audio_time = 0.0f;
 
+#ifdef WITH_AUDASPACE
 static AUD_Device* audio_mixdown_device = 0;
+#endif
 
 #define FFMPEG_AUTOSPLIT_SIZE 2000000000
 
@@ -103,6 +107,7 @@
    }
 }
 
+#ifdef WITH_AUDASPACE
 static int write_audio_frame(void)
 {
    AVCodecContext* c = NULL;
@@ -145,6 +150,7 @@
    }
    return 0;
 }
+#endif // #ifdef WITH_AUDASPACE
 
 /* Allocate a temporary frame */
 static AVFrame* alloc_picture(int pix_fmt, int width, int height)
@@ -851,7 +857,7 @@
    ffmpeg_autosplit_count = 0;
 
    success = start_ffmpeg_impl(rd, rectx, recty, reports);
-
+#ifdef WITH_AUDASPACE
    if(audio_stream)
    {
       AVCodecContext* c = audio_stream->codec;
@@ -861,12 +867,13 @@
       specs.rate = rd->ffcodecdata.audio_mixrate;
       audio_mixdown_device = sound_mixdown(scene, specs, rd->sfra, rd->ffcodecdata.audio_volume);
    }
-
+#endif
    return success;
 }
 
 void end_ffmpeg(void);
 
+#ifdef WITH_AUDASPACE
 static void write_audio_frames(double to_pts)
 {
    int finished = 0;
@@ -878,6 +885,7 @@
       }
    }
 }
+#endif
 
 int append_ffmpeg(RenderData *rd, int frame, int *pixels, int rectx, int recty, ReportList *reports)
 {
@@ -905,8 +913,9 @@
       }
    }
 
+#ifdef WITH_AUDASPACE
    write_audio_frames((frame - rd->sfra) / (((double)rd->frs_sec) / rd->frs_sec_base));
-
+#endif
    return success;
 }
 
@@ -920,12 +929,14 @@
       write_audio_frames();
    }*/
 
+#ifdef WITH_AUDASPACE
    if(audio_mixdown_device)
    {
       AUD_closeReadDevice(audio_mixdown_device);
       audio_mixdown_device = 0;
    }
-   
+#endif
+
    if (video_stream && video_stream->codec) {
       fprintf(stderr, "Flushing delayed frames...\n");
       flush_ffmpeg ();
